#!/bin/bash

# Script to download porteus updates for RC's

# Color definitions
txtund=$(tput sgr 0 1)          # Underline
txtbld=$(tput bold)             # Bold
txtred=${txtbld}$(tput setaf 1) #  red
txtgreen=${txtbld}$(tput setaf 2) #  green
txtyellow=${txtbld}$(tput setaf 3) #  yellow
txtblue=${txtbld}$(tput setaf 4) #  blue
txtpink=${txtbld}$(tput setaf 5) #  pink
txtcyan=${txtbld}$(tput setaf 6) #  cyan
txtwhite=${txtbld}$(tput setaf 7) #  white
rst=$(tput sgr0)             # Reset

function bold(){
echo -e $txtbld "$1" $rst
}

function green() {
echo -e $txtgreen "$1" $rst
}

function cyan(){
echo -e $txtcyan "$1" $rst
}

function red(){
echo $txtred "$1" $rst
}

menu() {
    echo "Avaliable options:"
    for i in ${!options[@]}; do 
        printf "%3d%s) %s\n" $((i+1)) "${choices[i]:- }" "${options[i]}"
    done
    [[ "$msg" ]] && echo "$msg"; :
}

# Root check
if [ "`id -u`" != "0" ]; then
    echo -e $txtbold "Only root can run this!" $rst
    cleanup
fi

# Vars
PORTVER=30
TMP=/tmp/pupdate_$$
[ `uname -m|grep -o "x86_64"` ] && ARCH=x86_64 || ARCH=i486
SERVER=http://ponce.cc/porteus/x86_64/testing/updates/
ERRORLOG=$TMP/error.log
DUMP=$TMP/dump
trap cleanup SIGHUP SIGINT SIGTERM

# Functions
cleanup(){
echo
if [ -e $ERRORLOG ]; then
    red "============================================="
    red " WARNING! WARNING! WARNING WARNING!"
    echo && echo " There was a fatal error with the updater:"
    bold "`cat $ERRORLOG`"
    rm -rf $TMP
fi
exit
}

check_version(){
VER=`grep -o [0-9].[0-9] /etc/porteus-version|tr -d [:punct:]`
[ $VER -lt $PORTVER ] && { echo "This script only runs on Porteus v3.0+" > $ERRORLOG; cleanup; }
[ `grep -o "rc[0-9]" /etc/porteus-version` ] && { echo "This script does not run on RC releases." > $ERRORLOG; cleanup; }
}

ask_base_folder(){
echo
bold "In order to continue, i need to know the path to your porteus/base directory."
echo " I will at least need a directory to store the download fixes."
echo
read -ep "Please type the path to your porteus/base directory `echo $'\n> '`" BASEDIRECTORY

# Check the directory
[ ! -d $BASEDIRECTORY ] && { red "This directory does not exist!"; $FUNCNAME; }
[ ! -w $BASEDIRECTORY ] && { red "This directory is NOT writable!."; $FUNCNAME; }
}

array_contains(){
  local e
  for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
  return 1
}

menu() {
    echo "Avaliable options:"
    for i in ${!required[@]}; do 
        printf "%3d%s) %s\n" $((i+1)) "${choices[i]:- }" "${required[i]}"
    done
    [[ "$msg" ]] && echo "$msg"; :
}

# Setup system
rm -rf /tmp/pupdate_*
mkdir $TMP
check_version

## Check for base directory. This is needed to continue
PF=`grep -A1 "Porteus data found in:" /var/log/porteus-livedbg|tail -n1|sed 's@//@/@g'`
BASEDIRECTORY=${PF}/base
if [ -n "$PF" -a ! "`grep -o emory <<<$PF`" ]; then
	BASEDIR=${BASEDIRECTORY%/*/*}
	PDIR=$PF
	BDIR=${BASEDIR}/boot
	[ ! -d $BDIR ] && unset BDIR
	OPTDIR=${PDIR/optional}
	[ ! -w $BASEDIRECTORY ] && ask_base_folder
else
	ask_base_folder
fi

# Netcheck
wget -q --spider --force-html --inet4-only $SERVER || { echo "The repository could not be reached. Please check your internet connection." > $ERRORLOG; cleanup; }

## Find which modules user is using and get appropriate updates.
mlmi=/mnt/live/memory/images
case `ls $mlmi/|awk -F- '/003/''{print$2}'|cut -d. -f1` in
kde )
desktop=kde ;;
mate )
desktop=mate ;;
razor )
desktop=razor ;;
lxde )
desktop=lxde ;;
xfce )
desktop=xfce ;;
gnome )
desktop=gnome ;;
esac

## Generate update lists
bold "Getting file list from server ..."
remotelist=(`lynx -dump -listonly -nonumbers $SERVER|egrep ".*$desktop.*.xzm$|.*alldesktops.*.xzm$"|awk -F/ '{print$NF}'`)
localist=(`ls $BASEDIRECTORY`)
echo
required=()
for i in "${remotelist[@]}"; do
  skip=
  for j in "${localist[@]}"; do
    [[ $i == $j ]] && { skip=1; break; }
  done
  [[ -n $skip ]] || required+=("$i")
done
required+=("Download all")
declare -p required >/dev/null

# Create menu with update choices for desktop in use
clear
prompt="Check an option (again to uncheck, ENTER when done): "
while menu && read -rp "$prompt" num && [[ "$num" ]]; do
    [[ "$num" != *[![:digit:]]* ]] && (( num > 0 && num <= ${#required[@]} )) || {
        msg="Invalid option: $num"; clear; continue
    }
    ((num--)); msg=""
    [[ "${choices[num]}" ]] && choices[num]="" || choices[num]="+"
clear
done

for i in ${!required[@]}; do 
    [[ "${choices[i]}" ]] && chosen+=("${required[i]}")
done
echo "$msg"

# Parse output from menu
[ ${#choices[@]} -eq 0 ] && { echo; bold "No packages were chosen. No action was taken."; cleanup; }
array_contains "Download all" "${chosen[@]}"

# Set final array files for download
if [ $? -eq 0 ]; then
    final=( ${required[@]/Download*/} ) && unset chosen
        else
    final=("${chosen[@]}") && unset chosen
fi

# Download chosen packages
echo
echo "Changing into $BASEDIRECTORY ..."
cd $BASEDIRECTORY
for a in ${final[@]}; do
    bold "Downloading $a ..." 
    wget $SERVER/$a
done
echo
bold "The following packages were downloaded: "
printf -- '%s\n' "${final[@]}"
echo
cd - >/dev/null
cleanup

# Useful lines
# comm -23 <(printf "%s\n" "${remotelist[@]}") <(printf "%s\n" "${localist[@]}")
